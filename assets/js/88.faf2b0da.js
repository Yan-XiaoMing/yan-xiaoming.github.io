(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{497:function(e,r,a){"use strict";a.r(r);var s=a(2),t=Object(s.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"service-worker-简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#service-worker-简介"}},[e._v("#")]),e._v(" Service Worker 简介")]),e._v(" "),r("p",[e._v("丢失网络连接是一个困扰 Web 用户多年的难题，即使是世界上最好的 Web App，如果因为网络原因访问不了它，那体验也是非常糟糕的。")]),e._v(" "),r("p",[e._v("通常所讲的 Service Worker 指的是 Service Worker 线程。了解浏览器工作原理的开发者都知道浏览器中执行的 JavaScript 文件是运行在一个单一线程上，称之为 "),r("strong",[e._v("主线程")]),e._v("。而 Service Worker 是一种独立于浏览器主线程的 "),r("strong",[e._v("工作线程")]),e._v("，与当前的浏览器主线程是完全隔离的，并有自己独立的执行上下文（context）。")]),e._v(" "),r("p",[e._v("HTML5 提供的一个 Service Worker API，能够进行 Service Worker 线程的注册、注销等工作，通过 "),r("code",[e._v("navigator.serviceWorker.register()")]),e._v(" 方法就能够注册一个 Service Worker，在当前的浏览器主线程的基础上新起一个 Service Worker 线程。")]),e._v(" "),r("p",[e._v("通常将可以被 "),r("code",[e._v("navigator.serviceWorker.register()")]),e._v(" 方法注册的 JavaScript 文件称之为 Service Worker 文件，可以是任何命名，在这个示例中命名为 "),r("code",[e._v("sw.js")]),e._v("，其内容就是在 Service Worker 线程上下文中执行的内容（如果文件为空代表 worker 线程什么也不会做），由于 Service Worker 线程是独立于主线程的工作线程，所以在 "),r("code",[e._v("sw.js")]),e._v(" 中的任何操作都不会影响到主线程。")]),e._v(" "),r("h2",{attrs:{id:"为什么有-service-worker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么有-service-worker"}},[e._v("#")]),e._v(" 为什么有 Service Worker")]),e._v(" "),r("p",[e._v("Service Worker 的来历可以从两个方面来介绍。")]),e._v(" "),r("h3",{attrs:{id:"一方面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一方面"}},[e._v("#")]),e._v(" 一方面")]),e._v(" "),r("p",[e._v("浏览器中的 JavaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，在 JavaScript 中的代码逻辑中往往会出现很多耗资源、耗时间的复杂运算过程。这些过程导致的性能问题在 Web App 日益增长的复杂化过程中更加凸显出来。所以 W3C 提出了 Web Worker API 来专门解放主线程，Web Worker 是脱离在主线程之外的工作线程，开发者可以将一些复杂的耗时的工作放在 Web Worker 中进行，工作完成后通过 postMessage 告诉主线程工作的结果，而主线程通过 onmessage 得到 Web Worker 的结果反馈，从而释放了主线程的性能压力。")]),e._v(" "),r("p",[e._v("代码执行性能问题好像是解决了，但 Web Worker 是临时存在的，每次做的事情的结果不能被持久存下来，如果下次访问 Web App 同样的复杂工作还是需要被 Web Worker 重新处理一遍，这同样是一件消耗资源的事情，只不过不是在主线程消耗罢了。那能不能有一个 Worker 线程是一直是可以持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求 W3C 推出了最初版本的 Service Worker，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力，可以通过自身的"),r("strong",[e._v("生命周期")]),e._v("特性保证复杂的工作只处理一次，并持久缓存处理结果，直到修改了 Service Worker 的内在的处理逻辑。")]),e._v(" "),r("h3",{attrs:{id:"另一方面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#另一方面"}},[e._v("#")]),e._v(" 另一方面")]),e._v(" "),r("p",[e._v("为了解决 Web 网络连接不稳定的问题，W3C 在很早的时候提出了 ApplicationCache 机制来解决离线缓存的问题，做法是在 HTML 页面中可以指定一个清单文件 "),r("code",[e._v("manifest.appcache")]),e._v("，清单中指定需要离线缓存的静态资源，ApplicationCache 能够解决离线可访问的问题。")]),e._v(" "),r("p",[e._v("假设已经存在一个简单的项目 applicationCacheDemo，项目目录如下：")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n└── applicationCacheDemo/\n    ├── index.html\n    └── manifest.appcache\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[e._v("下面是一个简单的 "),r("code",[e._v("manifest.appcache")]),e._v(" 配置文件内容：")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[e._v("CACHE MANIFEST\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# version xx.xx.xx")]),e._v("\nCACHE:\ncached.png\ncached.js\n\nNETWORK:\nnoCached.html\nnoCached.css\n\nFALLBACK:\n/ "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("404")]),e._v(".html\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br")])]),r("p",[r("code",[e._v("CACHE")]),e._v(" 字段配置了需要当前页面离线缓存的静态资源，"),r("code",[e._v("NETWORK")]),e._v(" 字段配置了当前页面不需要离线缓存的静态资源，"),r("code",[e._v("FALLBACK")]),e._v(" 字段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI，第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。有了 "),r("code",[e._v("manifest.appcache")]),e._v(" 文件之后，可以在 "),r("code",[e._v("index.html")]),e._v(" 的 HTML 文件中的 "),r("code",[e._v("<html>")]),e._v(" 标签进行引入从而指定当前页面的静态资源离线缓存的情况，如下面代码所示：")]),e._v(" "),r("div",{staticClass:"language-html line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-html"}},[r("code",[r("span",{pre:!0,attrs:{class:"token doctype"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<!")]),r("span",{pre:!0,attrs:{class:"token doctype-tag"}},[e._v("DOCTYPE")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token name"}},[e._v("html")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("html")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("manifest")]),r("span",{pre:!0,attrs:{class:"token attr-value"}},[r("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[e._v("=")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("./manifest.appcache"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("\x3c!--...--\x3e")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token tag"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("html")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("p",[e._v("虽然通过 ApplicationCache 机制能够解决 Web App 的离线缓存的问题，但是同时也带来了不小的问题：")]),e._v(" "),r("ul",[r("li",[e._v("在 manifest.appcache 文件中定义的资源全部被成功加载后，这些资源文件连同引用 manifest.appcahe 文件的 HTML 文档一并被移动到永久离线缓存中。所以如果想只缓存 JS、CSS、图片等文件，而不希望缓存 HTML 文档以保持获得最新内容的情况来说，是个非常大的问题。")]),e._v(" "),r("li",[e._v("根据 ApplicationCache 的加载机制，如果仅仅修改被缓存资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改 manifest.appcache 文件，以触发资源文件的重新加载和缓存，维护成本太高。")]),e._v(" "),r("li",[e._v("靠一个 manifest.appcache 配置文件来维护一个复杂的站点的缓存策略实在是一件非常艰难的工作，毕竟单纯靠配置是非常不灵活的。")]),e._v(" "),r("li",[e._v("对动态请求无法处理。")])]),e._v(" "),r("p",[e._v("通过一段时间的实践后，W3C 决定废弃 ApplicationCache，虽然其仍然保留在 HTML 5.0 Recommendation 中，但会在 HTML 后续版本中移除。一些主流浏览器甚至已经将 ApplicationCache 标注为不推荐使用，并引导开发者使用 Service Worker。Service Worker 就很好的解决了 ApplicationCache 的痛点问题，它能够通过非常多的缓存策略来灵活的管理 Web App 的离线缓存，大大降低维护成本（我们会在后面章节详细的讲解这部分的内容）。")]),e._v(" "),r("p",[e._v("基于 Woker 工作线程的离线能力和离线缓存机制的双重迫切需求，通过不断的实践和发展，W3C 最终提出的 Service Worker API 可以以独立工作线程的方式运行，结合持久缓存调度策略，能够很好的解决离线缓存问题。并且可以以非侵入的方式与现存的 Web App 结合使用，从可以实现 PWA 渐进式的离线与缓存的效果。")]),e._v(" "),r("h2",{attrs:{id:"service-worker-特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#service-worker-特点"}},[e._v("#")]),e._v(" Service Worker 特点")]),e._v(" "),r("p",[e._v("出于安全的考虑 Service Worker "),r("strong",[e._v("必须运行在 HTTPS 协议下")]),e._v("，Github 提供的 "),r("a",{attrs:{href:"https://pages.github.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("git page"),r("OutboundLink")],1),e._v("是个用来测试 Service Worker 的好地方，因为它就直接就支持 HTTPS，直接就可以测试静态页面和静态资源，为了便于本地开发，"),r("code",[e._v("localhost")]),e._v("、"),r("code",[e._v("127.0.0.1")]),e._v(" 这种非 HTTPS 协议也被浏览器认为是安全源。")]),e._v(" "),r("p",[e._v("Service Worker 线程"),r("strong",[e._v("有自己完全独立的执行上下文")]),e._v("。"),r("strong",[e._v("一旦被安装成功就永远存在，除非线程被程序主动解除")]),e._v("，而且 Service Worker 在访问页面的时候可以直接被激活，如果关闭浏览器或者浏览器标签的时候会自动睡眠，以减少资源损耗。")]),e._v(" "),r("p",[e._v("Service Worker 是完全异步实现的，内部的接口的异步化都是通过 Promise 实现，并且在 Service Worker 中"),r("strong",[e._v("不能直接操作 DOM")]),e._v("，出于安全和体验的考虑，UI 的渲染工作必须只能在主线程完成。")]),e._v(" "),r("p",[e._v("Service Worker "),r("strong",[e._v("可以拦截并代理请求，可以处理请求的返回内容")]),e._v("，可以持久化缓存静态资源达到离线访问的效果，和 ApplicationCache 不同，Service Worker 的所有的离线内容"),r("strong",[e._v("开发者完全可控")]),e._v("，甚至是可以控制动态请求，第三方静态资源等。")]),e._v(" "),r("p",[e._v("由于 Service Worker 可以离线并且在后台工作，所以可以进行 "),r("strong",[e._v("推送消息")]),e._v("、"),r("strong",[e._v("后台同步")]),e._v("资源等功能，在不久的将来，利用 Service Worker 的这一特性，甚至可以衍生出更多的 Web App 原生化的功能。")])])}),[],!1,null,null,null);r.default=t.exports}}]);