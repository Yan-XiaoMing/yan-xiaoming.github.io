(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{498:function(t,e,v){"use strict";v.r(e);var _=v(2),o=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"自动化采集优势及办法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动化采集优势及办法"}},[t._v("#")]),t._v(" 自动化采集优势及办法")]),t._v(" "),e("p",[t._v("**获取首屏时间，目前业界还是以自动化采集为主。**所谓自动化采集，即引入一段通用的代码来做首屏时间自动化采集，引入过程中，除了必要的配置不需要做其他事情。")]),t._v(" "),e("p",[t._v("自动化采集的好处是独立性更强，接入过程更自动化。具体的自动化采集代码，可以由一个公共团队来开发，试点后，推广到各个业务团队。而且统计结果更标准化，同一段统计代码，标准更统一，业务侧同学也更认可这个统计结果。")]),t._v(" "),e("p",[t._v("当然，它也有缺点，最明显的是，有些个性化需求无法满足，毕竟在工作中，总会有一些特殊业务场景。所以，采用自动化采集方案必须做一些取舍。")]),t._v(" "),e("h2",{attrs:{id:"服务端模板业务下的采集办法-ssr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务端模板业务下的采集办法-ssr"}},[t._v("#")]),t._v(" 服务端模板业务下的采集办法(SSR)")]),t._v(" "),e("p",[t._v("首先,服务端模板项目的加载流程：")]),t._v(" "),e("p",[e("code",[t._v("HTTP 请求 → HTML 文档加载解析完成 → 加载样式和脚本文件 → 完成页面渲染。")])]),t._v(" "),e("p",[t._v("所以:")]),t._v(" "),e("p",[t._v("HTML 文档"),e("strong",[t._v("加载解析完成的时间点")]),t._v("，就是"),e("strong",[t._v("首屏时间")]),t._v("点，而要采集这个首屏时间，可以用浏览器提供的 "),e("code",[t._v("DOMContentLoaded")]),t._v("接口来实现。")]),t._v(" "),e("p",[e("code",[t._v("DOMContentLoaded")]),t._v("在chrome调试工具中如下图:")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/Cgp9HWA-BM6AF77NAAHEtECWVO0860.png",alt:"Drawing 0.png"}})]),t._v(" "),e("p",[t._v("右侧中间竖向的一条蓝线，代表了 DOMContentLoaded 这个事件触发的时间，而下面的蓝色文字（DOMContentLoaded 1.02s），代表 HTML 元素加载解析完成用了 1.02 秒。根据服务端模板项目加载流程，我们就知道这个时间就是首屏时间。")]),t._v(" "),e("h3",{attrs:{id:"domcontentloaded-时间具体的采集思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#domcontentloaded-时间具体的采集思路"}},[t._v("#")]),t._v(" DOMContentLoaded 时间具体的采集思路")]),t._v(" "),e("p",[t._v("当页面中的 HTML 元素被加载和解析完成（不需要等待样式表、图片和一些脚本的加载过程），"),e("code",[t._v("DOMContentLoaded")]),t._v("事件触发。此时我们记录下当前时间 "),e("code",[t._v("domContentLoadedEventEnd")]),t._v("，再减去页面初始进入的时间 "),e("code",[t._v("fetchStart")]),t._v("，就是 "),e("code",[t._v("DOMContentLoaded")]),t._v(" 的时间，也就是我们要采集的首屏时间。\n即："),e("code",[t._v("首屏时间=DOMContentLoaded 时间=domContentLoadedEventEnd-fetchStart。")])]),t._v(" "),e("h2",{attrs:{id:"单页面-spa-应用业务下的采集办法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单页面-spa-应用业务下的采集办法"}},[t._v("#")]),t._v(" 单页面（SPA）应用业务下的采集办法")]),t._v(" "),e("p",[t._v("在 2018 年 6 月的 GMTC 大会上，阿里云曾分享了他们的一个首屏指标采集结果：")]),t._v(" "),e("blockquote",[e("p",[t._v("使用 Performance API 接口采集的首屏时间是 1106ms\n实际的首屏时间是 1976ms")])]),t._v(" "),e("p",[t._v("差别如此大的原因是: 在 "),e("code",[t._v("SPA")]),t._v(" 页面中，整体加载流程是这样的。")]),t._v(" "),e("p",[t._v("用户请求一个页面时，页面会先加载 index.html，加载完成后，就会触发 DOMContentLoaded 和 load。而这个时候，页面展示的只是个空白页。此时根本不算真正意义的首屏。接下来，页面会加载相关脚本资源并通过 axios 异步请求数据，使用数据渲染页面主题部分，这个时候首屏才渲染完成。")]),t._v(" "),e("p",[t._v("从而造成了用 Performance 接口取得的时间是 1106ms，实际时间则是 1976ms，差距如此之大。可以说，SPA 的流行让 Performance 接口失去了原来的意义。")]),t._v(" "),e("h3",{attrs:{id:"解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),e("p",[t._v("如果能在首屏渲染过程中，把各个资源的加载时间记录到日志中，后续再通过分析，确定某一个资源加载完的时间，就是首屏时间。而 "),e("code",[t._v("MutationObserver")]),t._v(" 恰恰可以做到这些。")]),t._v(" "),e("h3",{attrs:{id:"mutationobserver"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutationobserver"}},[t._v("#")]),t._v(" "),e("code",[t._v("MutationObserver")])]),t._v(" "),e("p",[t._v("MDN的定义:")]),t._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver",target:"_blank",rel:"noopener noreferrer"}},[e("code",[t._v("MutationObserver")]),e("OutboundLink")],1),t._v("接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。")])]),t._v(" "),e("p",[t._v("总结来说， 使用 MutationObserver 能监控页面信息的变化，当页面 body 变化最剧烈的时候，我们拿到的时间数据，就是首屏时间。")]),t._v(" "),e("h4",{attrs:{id:"大致过程如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大致过程如下"}},[t._v("#")]),t._v(" 大致过程如下：")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("首先")]),t._v("，在用户进入页面时，我们可以使用 MutationObserver 监控 DOM 元素 （Document Object Model，文档对象模型）。当 DOM 元素发生变化时，程序会标记变化的元素，记录时间点和分数，存储到数组中。数据的格式类似于 [200ms,18.5] 。")]),t._v(" "),e("p",[t._v("为了提升计算的效率，我们认为首屏指标采集到某些条件时，首屏渲染已经结束，我们需要考虑首屏采集终止的条件，即计算时间超过 30 秒还没有结束；计算了 4 轮且 1 秒内分数不再变化；计算了 9 次且分数不再变化。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("接下来")]),t._v("，设定元素权重计算分数。")]),t._v(" "),e("p",[t._v("递归遍历 DOM 元素及其子元素，根据子元素所在层数设定元素权重，比如第一层元素权重是 1，当它被渲染时得 1 分，每增加一层权重增加 0.5，比如第五层元素权重是 3.5，渲染时给出对应分数")]),t._v(" "),e("p",[t._v("为什么需要权重呢？")]),t._v(" "),e("p",[t._v("因为页面中每个 DOM 元素对于首屏的意义是不同的，越往内层越接近真实的首屏内容，如图片和文字，越往外层越接近 body 等框架层。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("最后")]),t._v("，根据前面的得分，计算元素的分数变化率，获取变化率最大点对应的分数。然后找到该分数对应的时间，即为首屏时间。")])])]),t._v(" "),e("p",[t._v("分数部分核心计算逻辑是递归遍历元素，将一些无用的标签排除，如果元素超过可视范围返回 0 分，每一层增加 0.5 的权重，")])])}),[],!1,null,null,null);e.default=o.exports}}]);