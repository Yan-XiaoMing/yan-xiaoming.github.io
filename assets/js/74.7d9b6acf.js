(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{483:function(t,a,v){"use strict";v.r(a);var _=v(2),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"版本号的变化-为什么不是-http-2-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本号的变化-为什么不是-http-2-0"}},[t._v("#")]),t._v(" 版本号的变化(为什么不是 HTTP/2.0)")]),t._v(" "),a("p",[a("strong",[t._v("HTTP/2 工作组特别给出了解释 :")])]),t._v(" "),a("p",[t._v("以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……这样就可以明确无误地辨别出协议版本的“跃进程度”，让协议在一段较长的时期内保持稳定，每当发布新版本的 HTTP 协议都会有本质的不同，绝不会有“零敲碎打”的小改良。")]),t._v(" "),a("h2",{attrs:{id:"http-2-的目标以及做了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的目标以及做了什么"}},[t._v("#")]),t._v(" HTTP/2 的目标以及做了什么")]),t._v(" "),a("h3",{attrs:{id:"http-2-的目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的目标"}},[t._v("#")]),t._v(" HTTP/2 的目标")]),t._v(" "),a("p",[t._v("HTTP/2 的唯一目标就是改进性能。因为在安全方向有了 HTTPS,并且 HTTPS 做的已经很好了。")]),t._v(" "),a("h3",{attrs:{id:"兼容-http-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兼容-http-1"}},[t._v("#")]),t._v(" "),a("strong",[t._v("兼容 HTTP/1")])]),t._v(" "),a("p",[t._v("HTTP/1 使用的场景和人数非常庞大，所以 HTTP/2 背负着 HTTP/1 庞大的历史包袱，所以协议的修改必须小心谨慎，兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产")]),t._v(" "),a("p",[a("strong",[t._v("那么，HTTP/2 是怎么做的呢?")])]),t._v(" "),a("p",[t._v("因为必须要保持功能上的兼容，HTTP/2 把 HTTP 分解成了**“语义”**和“**语法”**两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。")]),t._v(" "),a("h2",{attrs:{id:"http-2-的改动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2-的改动"}},[t._v("#")]),t._v(" HTTP/2 的改动")]),t._v(" "),a("h3",{attrs:{id:"头部压缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#头部压缩"}},[t._v("#")]),t._v(" "),a("strong",[t._v("头部压缩")])]),t._v(" "),a("p",[t._v("由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，“长尾效应”导致大量带宽消耗在了这些冗余度极高的数据上。")]),t._v(" "),a("p",[t._v("HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。")]),t._v(" "),a("p",[t._v("“HPACK”算法是专门为压缩 HTTP 头部定制的算法，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”，压缩和解压缩就是查表和更新表的操作。为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“"),a("strong",[t._v("伪头字段")]),t._v("”。起始行里的版本号和错误原因短语因为没什么大用，也废除了。")]),t._v(" "),a("h4",{attrs:{id:"静态表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态表"}},[t._v("#")]),t._v(" "),a("strong",[t._v("静态表")])]),t._v(" "),a("p",[t._v("为了与“真头字段”区分开来，这些“"),a("strong",[t._v("伪头字段")]),t._v("”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。这样一来 HTTP 报文头就变得简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的“"),a("strong",[t._v("静态表")]),t._v("”")]),t._v(" "),a("p",[t._v("比如数字“2”代表“GET”，数字“8”代表状态码 200。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/76/0c/769dcf953ddafc4573a0b4c3f0321f0c.png",alt:"img"}})]),t._v(" "),a("h4",{attrs:{id:"动态表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态表"}},[t._v("#")]),t._v(" "),a("strong",[t._v("动态表")])]),t._v(" "),a("p",[t._v("如果表里只有 Key 没有 Value，或者是自定义字段根本找不到该怎么办？")]),t._v(" "),a("p",[a("strong",[t._v("动态表")]),t._v("，它添加在静态表后面，结构相同，但会在编码解码的时候随时更新。")]),t._v(" "),a("p",[t._v("比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/5f/6f/5fa90e123c68855140e2b40f4f73c56f.png",alt:"img"}})]),t._v(" "),a("p",[t._v("随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。")]),t._v(" "),a("h3",{attrs:{id:"二进制帧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制帧"}},[t._v("#")]),t._v(" "),a("strong",[t._v("二进制帧")])]),t._v(" "),a("p",[t._v("HTTP/1 里是纯文本形式的报文，它的优点是“一目了然”，用最简单的工具就可以开发调试，非常方便。")]),t._v(" "),a("p",[t._v("但 在 HTTP/2 决定改变现状，不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。")]),t._v(" "),a("p",[t._v("虽然对人不友好，但却大大方便了计算机的解析。原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。")]),t._v(" "),a("p",[a("strong",[t._v("修改内容：")])]),t._v(" "),a("p",[t._v("把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。HTTP/2 数据分帧后“Header+Body”的报文结构就完全消失了，协议看到的只是一个个的“碎片”。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/8f/96/8fe2cbd57410299a1a36d7eb105ea896.png",alt:"img"}})]),t._v(" "),a("h3",{attrs:{id:"流-与多路复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流-与多路复用"}},[t._v("#")]),t._v(" "),a("strong",[t._v("“流”与多路复用")])]),t._v(" "),a("p",[t._v("碎片”到达目的地后应该怎么组装?")]),t._v(" "),a("p",[t._v("HTTP/2 为此定义了一个“流”（Stream）的概念，它是"),a("strong",[t._v("二进制帧的双向传输序列")]),t._v("，同一个消息往返的帧会分配一个唯一的流 ID。")]),t._v(" "),a("p",[t._v("在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都"),a("strong",[t._v("拥有相同的流 ID")]),t._v("，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/68/33/688630945be2dd51ca62515ae498db33.png",alt:"img"}})]),t._v(" "),a("p",[t._v("因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。")]),t._v(" "),a("p",[t._v("在概念上，一个 HTTP/2 的流就等同于一个 HTTP/1 里的“请求 - 应答”。在 HTTP/1 里一个“请求 - 响应”报文来回是一次 HTTP 通信，在 HTTP/2 里一个流也承载了相同的功能。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b4/7e/b49595a5a425c0e67d46ee17cc212e7e.png",alt:"img"}})]),t._v(" "),a("p",[t._v("为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。")]),t._v(" "),a("p",[t._v("HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。")]),t._v(" "),a("h4",{attrs:{id:"流的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流的特点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("流的特点")])]),t._v(" "),a("ol",[a("li",[t._v("流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；")]),t._v(" "),a("li",[t._v("客户端和服务器都可以创建流，双方互不干扰；")]),t._v(" "),a("li",[t._v("流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；")]),t._v(" "),a("li",[t._v("流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；")]),t._v(" "),a("li",[t._v("流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；")]),t._v(" "),a("li",[t._v("流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；")]),t._v(" "),a("li",[t._v("在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；")]),t._v(" "),a("li",[t._v("第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);