(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{490:function(e,s,r){"use strict";r.r(s);var v=r(2),n=Object(v.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("说到负载均衡，我想说它天生就是不公平的。为什么这么说呢？请你想象这么一个场景，一块蛋糕切成5份，现在要将它分给A、B、C3个人，基于公平原则，我们说每个人正常可以分到5/3份，但是，5/3份很明显不好进行划分，诶碰巧这个时候A中午没有吃饭，能多吃几份，B、C肚子偏饱，1份即可，基于不公平原则，我们分给A3份蛋糕，B、C个一份，这样按照一定策略将资源进行划分的方式，是一种均衡的策略。")]),e._v(" "),s("p",[e._v("在web应用中，一个web应用（或者说某个服务）在生产环境中一般是集群部署，然后采用负载均衡硬件(F5)或者软件（nginx）将请求分发到不同的服务主机中进行处理，很明显，这里的蛋糕就相当于我们的web request，假设有5个request进来，基于一定的均衡策略，我们可能会将其中的3个request交给A服务器去处理，B、C服务器各处理1个request。下面我画张图片简单说明这个模型：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/8/1651734ffd395b3a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),s("p",[e._v("那么使用负载均衡有什么好处呢？首先优化资源利用率，最大化吞吐量，减少延迟，再者系统的伸缩性和可靠性也得到了相应的保障。")]),e._v(" "),s("h2",{attrs:{id:"一、nginx-负载均衡及相关策略介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、nginx-负载均衡及相关策略介绍"}},[e._v("#")]),e._v(" 一、Nginx 负载均衡及相关策略介绍")]),e._v(" "),s("p",[e._v("负载均衡技术少不了相关的均衡策略，Nginx 中提供了 4 种均衡策略，我们可以根据具体的业务场景选择合适的均衡策略。下面分别介绍这 4 中均衡策略：")]),e._v(" "),s("ul",[s("li",[s("p",[s("strong",[e._v("1、基于轮询的均衡策略：")])]),e._v(" "),s("p",[e._v("轮询嘛，就是说对进到nginx的request按照遍历的方式进行分发，如果request 1 分发到 Server A，那么request 2将被分发到 Server B,......以此循环类推")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("2、基于最少连接数的均衡策略：")])]),e._v(" "),s("p",[e._v("最少连接，也就是说nginx会判断后端集群服务器中哪个Server当前的 Active Connection 数是最少的，那么对于每个新进来的request,nginx将该request分发给对应的Server.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("3、基于ip-hash的均衡策略：")])]),e._v(" "),s("p",[e._v("我们都知道，每个请求的客户端都有相应的ip地址，该均衡策略中，nginx将会根据相应的hash函数，对每个请求的ip作为关键字，得到的hash值将会决定将请求分发给相应Server进行处理")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("4、基于加权轮询的均衡策略：")])]),e._v(" "),s("p",[e._v("加权轮询，很显然这个策略跟我们开题引入的场景是一样的，nginx会给Server配置相应的权重，权重越大，接收的request数将会越多")])])]),e._v(" "),s("p",[e._v("上面的均衡策略其实都非常很好理解，但是如果想了解其实现原理，可以看源代码，但是小编就算了，我是看不懂C、C++的。")]),e._v(" "),s("h2",{attrs:{id:"二、nginx-不同均衡策略的配置介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、nginx-不同均衡策略的配置介绍"}},[e._v("#")]),e._v(" 二、Nginx 不同均衡策略的配置介绍")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("1、基于轮询的均衡策略：")])])]),e._v(" "),s("p",[e._v("这个是Nginx默认的均衡算法，如果你不进行相关的配置，默认会执行该策略，配置如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("http {\n    upstream myapp1 {\n        server srv1.example.com;\n        server srv2.example.com;\n        server srv3.example.com;\n    }\n    server {\n        listen 80;\n\n        location / {\n            proxy_pass http://myapp1;\n        }\n    }\n}\n复制代码\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])]),s("p",[e._v("可以看出，nginx负载均衡使用到的指令不多，其中比较重要的两个是"),s("code",[e._v("upstream")]),e._v("和"),s("code",[e._v("proxy_pass")]),e._v(","),s("code",[e._v("upstream")]),e._v("块定义一个后端小集群，里边配置相关的Server组成这个集群，同时"),s("code",[e._v("upstream")]),e._v("为这个集群起个相应的名字，本实例叫"),s("code",[e._v("myapp1")]),e._v("."),s("code",[e._v("proxy_pass")]),e._v("处于"),s("code",[e._v("location")]),e._v("块中，表示对于所有符合"),s("code",[e._v("/")]),e._v("的request，将会交给哪个集群进行处理，本实例为"),s("code",[e._v("http://myapp1")]),e._v("。")]),e._v(" "),s("p",[e._v("但又一点我们需要注意，上面"),s("code",[e._v("http://myapp1")]),e._v("中"),s("code",[e._v("myapp1")]),e._v("必须是"),s("code",[e._v("upstream")]),e._v("起的名字，对于协议是使用"),s("code",[e._v("http")]),e._v("还是"),s("code",[e._v("https")]),e._v(",都无所谓，如果你的协议使用"),s("code",[e._v("https")]),e._v("，则将"),s("code",[e._v("http")]),e._v("直接改成"),s("code",[e._v("https")]),e._v("即可。另外，如果你在"),s("code",[e._v("upstream")]),e._v("中的"),s("code",[e._v("server")]),e._v("指令中指定了协议名，那么在"),s("code",[e._v("proxy_pass")]),e._v("指令中就不需要加上协议名称了。")]),e._v(" "),s("p",[e._v("nginx负载均衡使用反向代理实现，也就是我们上面使用到的"),s("code",[e._v("proxy_pass")]),e._v("指令，支持的协议不止是"),s("code",[e._v("http")]),e._v("和"),s("code",[e._v("https")]),e._v(",同时还支持"),s("code",[e._v("FastCGI")]),e._v("、"),s("code",[e._v("uwsgi")]),e._v("、"),s("code",[e._v("SCGI")]),e._v("、"),s("code",[e._v("memcached")]),e._v("、"),s("code",[e._v("gRPC")]),e._v("，如果你需要使用除了"),s("code",[e._v("http")]),e._v("、"),s("code",[e._v("https")]),e._v("外的其他协议，我们不能使用"),s("code",[e._v("proxy_pass")]),e._v("指令了，应该转而使用相应的指令，如"),s("code",[e._v("fastcgi_pass")]),e._v("、"),s("code",[e._v("uwsgi_pass")]),e._v("、"),s("code",[e._v("scgi_pass")]),e._v("、"),s("code",[e._v("memcached_pass")]),e._v("、"),s("code",[e._v("grpc_pass")]),e._v("。")]),e._v(" "),s("p",[e._v("该策略处理负载，小编认为还是有缺陷的，不能防止某台Server出现负载过高的情况。因为如果有些请求执行时间过长，而系统的并发量却非常大，那么就可能导致某台Server出现request堆积，负载过高，"),s("code",[e._v("snowslide is possible~")])]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("2、基于最少连接数的均衡策略：")])])]),e._v(" "),s("p",[e._v("该策略主要使用了"),s("code",[e._v("least_conn")]),e._v("指令，具体配置如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" upstream myapp1 {\n        least_conn;\n        server srv1.example.com;\n        server srv2.example.com;\n        server srv3.example.com;\n    }\n复制代码\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("该策略还是比较人性化的，可以按照机器的实际情况进行刚需分配。")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("3、基于ip-hash的均衡策略：")])])]),e._v(" "),s("p",[e._v("当然了，如果我们想实现这样一个功能，我们想让对于相同客户端的请求每次都被分发到同一个Server进行处理，上面两种策略都是不做到。此策略可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。相关配置如下：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("upstream myapp1 {\n    ip_hash;\n    server srv1.example.com;\n    server srv2.example.com;\n    server srv3.example.com;\n}\n复制代码\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("既然相同客户端的请求能被同一台Server进行处理，那么相同客户端的会话Session就可以实现持久化了。")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("4、基于加权轮询的均衡策略：")])])]),e._v(" "),s("p",[e._v("基于加权轮询的策略就不需要过多讲解了，就是在轮询的基础上加上个权重信息")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("upstream myapp1 {\n    server srv1.example.com weight=3;\n    server srv2.example.com;\n    server srv3.example.com;\n}\n复制代码\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("这种策略适合Server机器处理能力有区别的情况。")]),e._v(" "),s("h3",{attrs:{id:"三、nginx-负载均衡更多高级特性及配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、nginx-负载均衡更多高级特性及配置"}},[e._v("#")]),e._v(" 三、nginx 负载均衡更多高级特性及配置")]),e._v(" "),s("ul",[s("li",[s("p",[s("strong",[e._v("1、健康检查")])]),e._v(" "),s("p",[e._v("不仅人需要体检，机器也是需要体检的，那么就当nginx就是那位体检医生吧！nginx健康检查是什么呢？当我们一个request进来被分发到相应的Server进行处理后，nginx会检查该request执行是否超时，是否执行失败了等情况，然后做出相应的处理---比如说当nginx检查出Server A执行某request时报出502错误了，那么下次nginx负载均衡时就会在"),s("code",[e._v("upstream")]),e._v("块中将Server A排除掉，不分发请求给到Server A了。")]),e._v(" "),s("p",[e._v("对于健康检查的功能，nginx提供了基本两个指令，即"),s("code",[e._v("max_fails")]),e._v("和"),s("code",[e._v("fail_timeout")]),e._v(",也就是说当nginx检查到某Server发生错误的request数达到"),s("code",[e._v("max_fails")]),e._v("或者执行某request执行时间超过"),s("code",[e._v("fail_timeout")]),e._v("了，如果发生超时了，nginx将开始使用实时请求优雅地探测Server，如果有响应，则认为对应的Server还是活着的，没有毛病的。")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("2、更多配置")])]),e._v(" "),s("p",[e._v("针对上面"),s("code",[e._v("upstream")]),e._v("块中的"),s("code",[e._v("server")]),e._v("指令，其格式为："),s("code",[e._v("server address [parameters];")]),e._v("，里边的"),s("code",[e._v("parameters")]),e._v("可以有很多的参数类型，比如说指定某台Server不参与负载均衡等。具体配置详见官网链接，点击此处"),s("a",{attrs:{href:"http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server",target:"_blank",rel:"noopener noreferrer"}},[e._v("传送门"),s("OutboundLink")],1),e._v("。")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);